#define DQUOTE \x22
#define SQUOTE \x27

#ifdef GO
{
    package zql
    import "github.com/mccanne/zq/reglob"
}
#define RETURN(x) return x, nil
#define NULL nil
#define INIT_ASSIGN_VAR(x, var) x := var
#define ARRAY(...) []interface{}{__VA_ARGS__}
#define ARRAY_LEN(a) len(a.([]interface{}))
#define FOREACH(arr, var) for _, var := range arr
#define IF(stmt) if stmt
#define APPEND(arr, value) arr = append(arr, value)
#define PREPEND(value, arr) append([]interface{}{value}, (arr.([]interface{}))...)
#define TEXT string(c.text)
#define TOSTRING(s) fmt.Sprintf("%v", s)
#define ISNOTNULL(n) n != nil
#define ASSERT_ARRAY(a) a.([]interface{})
#define ASSERT_STRING(s) s.(string)
#define ASSERT_INT(i) i.(int)
#else
{
#include "parser-support.js"
}
#define RETURN(x) return x
#define NULL null
#define INIT_ASSIGN_VAR(x, var) let x = var
#define ARRAY(...) [__VA_ARGS__]
#define ARRAY_LEN(a) a.length
#define FOREACH(arr, var) for(let var of arr)
#define IF(stmt) if (stmt)
#define APPEND(arr, value) arr.push(value)
#define PREPEND(value, arr) [value, ...arr]
#define TEXT text()
#define ASSERT_INT(i) i
#define TOSTRING(s) s.toString()
#define ISNOTNULL(n) (n)
#define ASSERT_ARRAY(a) a
#define ASSERT_STRING(s) s
#endif


start = _? ast:boomCommand _? EOF { RETURN(ast) }

boomCommand
  = procs:procChain {
      INIT_ASSIGN_VAR(filt, makeFilterProc(makeBooleanLiteral(true)))
      RETURN(makeSequentialProc(PREPEND(filt, procs)))
    }
  / s:search _? rest:chainedProc* {
      if(ARRAY_LEN(rest) == 0) {
          RETURN(s)
      } else {
          RETURN(makeSequentialProc(PREPEND(s, rest)))
      }
    }
  / s:search {
      RETURN(makeSequentialProc(ARRAY(s)))
    }

procChain
  = first:proc rest:chainedProc* {
      IF(ISNOTNULL(rest)) {
        RETURN(PREPEND(first, rest))
      } else {
        RETURN(ARRAY(first))
      }
    }

chainedProc = _? "|" _? p:proc { RETURN(p) }

search
  = expr:searchExpr {
      RETURN(makeFilterProc(expr))
    }

searchExpr
  = first:searchTerm rest:oredSearchTerm* {
      RETURN(makeOrChain(first, rest))
    }

oredSearchTerm = _ orToken _ t:searchTerm { RETURN(t) }

searchTerm
  = first:searchFactor rest:andedSearchTerm* {
      RETURN(makeAndChain(first, rest))
    }

andedSearchTerm = _ (andToken _)? f:searchFactor { RETURN(f) }

searchFactor
  = (notToken _ / "!" _?) e:searchExpr {
      RETURN(makeLogicalNot(e))
    }
  / !("-") s:searchPred { RETURN(s) }
  / "(" _? expr:searchExpr _? ")" { RETURN(expr) }

searchPred
  = "*" _? fieldComparator:equalityToken _? v:searchValue {
      RETURN(makeCompareAny(fieldComparator, false, v))
    }
  / "**" _? fieldComparator:equalityToken _? v:searchValue {
      RETURN(makeCompareAny(fieldComparator, true, v))
    }
  / "*" {
      RETURN(makeBooleanLiteral(true))
    }
  / f:fieldExpr _? fieldComparator:equalityToken _? v:searchValue {
      RETURN(makeCompareField(fieldComparator, f, v))
    }
  / v:searchValue _? inToken _? "*" {
      RETURN(makeCompareAny("in", false, v))
    }
  / v:searchValue _? inToken _? f:fieldReference {
      RETURN(makeCompareField("in", f, v))
    }
  / v:searchValue {
      INIT_ASSIGN_VAR(ss, makeSearchString(v))
      IF(getValueType(v) == "string") {
        RETURN(ss)
      }
      ss = makeSearchString(makeTypedValue("string", TEXT))
      RETURN(makeOrChain(ss, ARRAY(makeCompareAny("eql", true, v), makeCompareAny("in", true, v))))
    }

searchValue
  = v:quotedString {
      RETURN(makeTypedValue("string", v))
    }
  / v:reString {
      RETURN(makeTypedValue("regexp", v))
    }
  / v:port {
      RETURN(makeTypedValue("port", v))
  }
  / v:ip6subnet {
      RETURN(makeTypedValue("subnet", v))
    }
  / v:ip6addr {
      RETURN(makeTypedValue("addr", v))
    }
  / v:subnet {
      RETURN(makeTypedValue("subnet", v))
    }
  / v:addr {
      RETURN(makeTypedValue("addr", v))
    }
  / v:sdouble {
      RETURN(makeTypedValue("double", v))
    }
  / v:sinteger !boomWord {
      RETURN(makeTypedValue("int", v))
    }
  / !(searchKeywords _) v:booleanLiteral { RETURN(v) }
  / !(searchKeywords _) v:unsetLiteral { RETURN(v) }
  / !(searchKeywords _) v:boomWord {
      IF(reglob.IsGlobby(ASSERT_STRING(v)) || ASSERT_STRING(v) == "*") {
         INIT_ASSIGN_VAR(re, reglob.Reglob(ASSERT_STRING(v)))
         RETURN(makeTypedValue("regexp", re))
      }
      RETURN(makeTypedValue("string", v))
    }

searchKeywords
  = andToken
  / orToken
  / inToken

booleanLiteral
  = "true"           { RETURN(makeTypedValue("bool", "true")) }
  / "false"          { RETURN(makeTypedValue("bool", "false")) }

unsetLiteral
  = "nil"           { RETURN(makeTypedValue("unset", "")) }

procList
  = first:procChain rest:parallelChain* {
      INIT_ASSIGN_VAR(fp, makeSequentialProc(first))
      IF(ISNOTNULL(rest)) {
        RETURN(makeParallelProc(PREPEND(fp, rest)))
      } else {
        RETURN(fp)
      }
    }

parallelChain
  = _? ";" _? ch:procChain { RETURN(makeSequentialProc(ch)) }

proc
  = simpleProc
  / reducerProc
  / "(" _? proc:procList _? ")" {
      RETURN(proc)
    }

groupBy
  = "by"i _ list:fieldExprList { RETURN(list) }

everyDur
  = "every"i _ dur:duration { RETURN(dur) }

equalityToken
  = "=" { RETURN("eql") }
  / "!=" { RETURN("neql") }
  / "<=" { RETURN("lte") }
  / ">=" { RETURN("gte") }
  / "<" { RETURN("lt") }
  / ">" { RETURN("gt") }

types
  = "bool"
  / "int"
  / "count"
  / "double"
  / "string"
  / "addr"
  / "subnet"
  / "port"

dash = "-" / "\u2014" / "\u2013" / "to"&(_)

andToken = "and"
orToken = "or"
inToken = "in"
notToken = "not"

fieldName = fieldNameStart fieldNameRest* { RETURN(TEXT) }

fieldNameStart = [A-Za-z_$]
fieldNameRest = fieldNameStart / [0-9]

fieldReference
 = base:fieldName derefs:(
       "." field:fieldName    { RETURN(makeFieldCall("RecordFieldRead", NULL, field)) }
     / "[" index:sinteger "]" { RETURN(makeFieldCall("Index", NULL, index)) }
   )* {
     RETURN(chainFieldCalls(base, derefs))
   }

fieldExpr
  = op:fieldOp _? "(" _? field:fieldReference _? ")" {
      RETURN(makeFieldCall(op, field, nil))
    }
  / fieldReference

fieldOp
  = "len"i { RETURN("Len") }

fieldExprList
  = first:fieldExpr rest:(_? "," _? fieldExpr)* {
      INIT_ASSIGN_VAR(result, ARRAY(first))

      FOREACH(ASSERT_ARRAY(rest), r) {
        APPEND(result, ASSERT_ARRAY(r)[3])
      }

      RETURN(result)
  }

fieldNameList
  = first:fieldName rest:(_? "," _? fieldName)* {
      INIT_ASSIGN_VAR(result, ARRAY(first))
      FOREACH(ASSERT_ARRAY(rest), r) {
        APPEND(result, ASSERT_ARRAY(r)[3])
      }
      RETURN(result)
  }

countOp
  = "count"i { RETURN("Count") }

fieldReducerOp
  = "sum"i  { RETURN("Sum") }
  / "avg"i  { RETURN("Avg") }
  / "stdev"i { RETURN("Stdev") }
  / "sd"i   { RETURN("Stdev") }
  / "var"i  { RETURN("Var") }
  / "entropy"i { RETURN("Entropy") }
  / "min"i  { RETURN("Min") }
  / "max"i  { RETURN("Max") }
  / "first"i  { RETURN("First") }
  / "last"i  { RETURN("Last") }
  / "countdistinct"i { RETURN("CountDistinct") }

paddedFieldName = _? field:fieldName _? { RETURN(field) }

countReducer
  = op:countOp _? "(" field:paddedFieldName?  _? ")" {
    RETURN(makeReducer(op, "count", field))
  }

fieldReducer
  = op:fieldReducerOp _? "(" _? field:fieldName  _? ")" {
    RETURN(makeReducer(op, toLowerCase(op), field))
  }

reducerProc
  = every:(everyDur _)? reducers:reducerList keys:(_ groupBy)? limit:procLimitArg? {
    if ISNOTNULL(OR(keys, every)) {
      if ISNOTNULL(keys) {
        keys = ASSERT_ARRAY(keys)[1]
      } else {
        keys = ARRAY()
      }

      if ISNOTNULL(every) {
        every = ASSERT_ARRAY(every)[0]
      }

      RETURN(makeGroupByProc(every, limit, keys, reducers))
    }

    RETURN(makeReducerProc(reducers))
  }

asClause
  = "as"i _ v:fieldName { RETURN(v) }

reducerExpr
  = field:fieldName _? "=" _? f:reducer {
    RETURN(overrideReducerVar(f, field))
  }
  / f:reducer _ field:asClause {
    RETURN(overrideReducerVar(f, field))
  }
  / reducer

reducer
  = countReducer
  / fieldReducer

reducerList
  = first:reducerExpr rest:(_? "," _? reducerExpr)* {
      INIT_ASSIGN_VAR(result, ARRAY(first))
      FOREACH(ASSERT_ARRAY(rest), r) {
        APPEND(result, ASSERT_ARRAY(r)[3])
      }
      RETURN(result)
    }

simpleProc
  = sort
  / top
  / cut
  / head
  / tail
  / filter
  / uniq

sort
  = "sort"i rev:(_ "-r")? limit:procLimitArg?  _? !"-r" list:(fieldExprList)? {
    INIT_ASSIGN_VAR(sortdir, 1)
    IF(ISNOTNULL(rev)) { sortdir = -1 }
    RETURN(makeSortProc(list, sortdir, limit))
  }
  / "sort"i limit:procLimitArg? rev:(_ "-r")? _? list:(fieldExprList)? {
    INIT_ASSIGN_VAR(sortdir, 1)
    IF(ISNOTNULL(rev)) { sortdir = -1 }
    RETURN(makeSortProc(list, sortdir, limit))
  }

top
  = "top"i limit:procLimitArg? flush:(_ "-flush")? _? list:(fieldExprList)? {
    RETURN(makeTopProc(list, limit, flush))
  }

procLimitArg
  = _ "-limit" _ limit:integer { RETURN(limit) }

cut
  = "cut"i _ list:fieldNameList { RETURN(makeCutProc(list)) }
head
  = "head"i _ count:integer { RETURN(makeHeadProc(count)) }
  / "head"i { RETURN(makeHeadProc(1)) }
tail
  = "tail"i _ count:integer { RETURN(makeTailProc(count)) }
  / "tail"i { RETURN(makeTailProc(1)) }

filter
  = "filter"i _ expr:searchExpr {
      RETURN(makeFilterProc(expr))
    }
uniq
  = "uniq"i _ "-c" {
      RETURN(makeUniqProc(true))
    }
  / "uniq"i {
      RETURN(makeUniqProc(false))
    }

duration
  = seconds
  / minutes
  / hours
  / hours _ "and" _ minutes
  / days
  / weeks

sec_abbrev
  = "seconds"
  / "second"
  / "secs"
  / "sec"
  / "s"

min_abbrev
  = "minutes"
  / "minute"
  / "mins"
  / "min"
  / "m"

hour_abbrev
  = "hours"
  / "hrs"
  / "hr"
  / "h"
  / "hour"

day_abbrev = "days"/"day"/"d"
week_abbrev = "weeks"/"week"/"wks"/"wk"/"w"

seconds
  = "second" { RETURN(makeDuration(1)) }
  / num:number _? sec_abbrev { RETURN(makeDuration(num)) }

minutes
  = "minute" { RETURN(makeDuration(60)) }
  / num:number _? min_abbrev { RETURN(makeDuration(ASSERT_INT(num)*60)) }

hours
  = "hour" { RETURN(makeDuration(3600)) }
  / num:number _? hour_abbrev { RETURN(makeDuration(ASSERT_INT(num)*3600)) }

days
  = "day" { RETURN(makeDuration(3600*24)) }
  / num:number _? day_abbrev { RETURN(makeDuration(ASSERT_INT(num)*3600*24)) }

weeks
  = num:number _? week_abbrev { RETURN(makeDuration(ASSERT_INT(num)*3600*24*7)) }

number = integer


//XXX what about mac addrs?
addr
  = a:(integer "." integer "." integer "." integer) { RETURN(TEXT) }

port
  = ":" v:sinteger { RETURN(v) }

// this matches a superset of legal syntax for ip6 addresses but the compiler
// will catch any errors when translating the filter
ip6addr
  = a:(h_prepend)+ b:ip6tail {
      RETURN(joinChars(a) + ASSERT_STRING(b))
    }
  / a:h16 b:(h_append)* "::" d:(h_prepend)* e:ip6tail {
      RETURN(ASSERT_STRING(a) + joinChars(b) + "::" + joinChars(d) + ASSERT_STRING(e))
    }
  / "::" a:(h_prepend)* b:ip6tail {
      RETURN("::" + joinChars(a) + ASSERT_STRING(b))
    }
  / a:h16 b:(h_append)* "::" {
      RETURN(ASSERT_STRING(a) + joinChars(b) + "::")
    }
  / "::" {
      RETURN("::")
    }

ip6tail
  = addr
  / h16

h_append = ":" v:h16 { RETURN(":" + ASSERT_STRING(v)) }
h_prepend = v:h16 ":" { RETURN(ASSERT_STRING(v) + ":") }

sub_addr
  = addr
  / a:(integer "." integer "." integer ) { RETURN(TEXT + ".0") }
  / a:(integer "." integer ) { RETURN(TEXT + ".0.0") }
  / a:integer { RETURN(TEXT + ".0.0.0") }

subnet
  = a:sub_addr '/' m:integer {
      RETURN(ASSERT_STRING(a) + "/" + TOSTRING(m));
    }

ip6subnet
  = a:ip6addr '/' m:integer {
      RETURN(ASSERT_STRING(a) + "/" + ASSERT_STRING(m));
    }

integer
  = s:sinteger {
    RETURN(parseInt(s))
  }

sinteger
  = chars:[0-9]+ {
    RETURN(TEXT)
  }

double
  = s:sdouble {
      RETURN(parseFloat(s))
  }

sdouble
  = doubleInteger+ "." doubleDigit+ exponentPart? {
      RETURN(TEXT)
    }
  / "." doubleDigit+ exponentPart? {
      RETURN(TEXT)
    }

doubleInteger
  = "0"
  / [1-9] [0-9]*

doubleDigit = [0-9]

signedInteger = [+-]? doubleDigit+

exponentPart = "e"i signedInteger

h16 = chars:hexdigit+ { RETURN(TEXT) }

hexdigit = [0-9a-fA-F]

boomWord "boomWord" = chars:boomWordPart+ { RETURN(TEXT) }

boomWordPart
  = !([\x00-\x1F\x5C(),!><=DQUOTE|SQUOTE;] / ws) .

quotedString
  = '"' v:doubleQuotedChar* '"' { RETURN(joinChars(v)) }
  / "'" v:singleQuotedChar* "'" { RETURN(joinChars(v)) }

doubleQuotedChar
  = !('"' / escapedChar) . { RETURN(TEXT) }
  / "\\" s:escapeSequence { RETURN(s) }

singleQuotedChar
  = !("'" / escapedChar) . { RETURN(TEXT) }
  / "\\" s:escapeSequence { RETURN(s) }

escapeSequence = singleCharEscape / unicodeEscape

singleCharEscape
  = "'"
  / '"'
  / "\\"
  / "b" { RETURN("\b") }
  / "f" { RETURN("\f") }
  / "n" { RETURN("\n") }
  / "r" { RETURN("\r") }
  / "t" { RETURN("\t") }
  / "v" { RETURN("\v") }

unicodeEscape
  = "u" hexdigit hexdigit hexdigit hexdigit

reString
  = '/' v:reBody '/' { RETURN(v) }

reBody
  = ([^/\\]/"\\/")+ { RETURN(TEXT) }

escapedChar
  = [\x00-\x1f\\]

ws
  = "\t"
  / "\v"
  / "\f"
  / " "
  / "\u00A0"
  / "\uFEFF"

_ "whitespace" = ws+

EOF = !.
