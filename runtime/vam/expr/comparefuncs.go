// Code generated by gencomparefuncs.go. DO NOT EDIT.

package expr

import (
	"github.com/brimdata/super"
	"github.com/brimdata/super/vector"
	"github.com/brimdata/super/vector/bitvec"
)

func compareEQIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(super.NewBool(lconst == rconst), lhs.Len(), bitvec.Zero)
}

func compareEQUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(super.NewBool(lconst == rconst), lhs.Len(), bitvec.Zero)
}

func compareEQFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(super.NewBool(lconst == rconst), lhs.Len(), bitvec.Zero)
}

func compareEQStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(super.NewBool(lconst == rconst), lhs.Len(), bitvec.Zero)
}

func compareEQBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) == string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) == string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) == string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(super.NewBool(string(lconst) == string(rconst)), lhs.Len(), bitvec.Zero)
}

func compareNEIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(super.NewBool(lconst != rconst), lhs.Len(), bitvec.Zero)
}

func compareNEUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(super.NewBool(lconst != rconst), lhs.Len(), bitvec.Zero)
}

func compareNEFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(super.NewBool(lconst != rconst), lhs.Len(), bitvec.Zero)
}

func compareNEStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(super.NewBool(lconst != rconst), lhs.Len(), bitvec.Zero)
}

func compareNEBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) != string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) != string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) != string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(super.NewBool(string(lconst) != string(rconst)), lhs.Len(), bitvec.Zero)
}

func compareLTIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(super.NewBool(lconst < rconst), lhs.Len(), bitvec.Zero)
}

func compareLTUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(super.NewBool(lconst < rconst), lhs.Len(), bitvec.Zero)
}

func compareLTFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(super.NewBool(lconst < rconst), lhs.Len(), bitvec.Zero)
}

func compareLTStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(super.NewBool(lconst < rconst), lhs.Len(), bitvec.Zero)
}

func compareLTBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) < string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) < string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) < string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(super.NewBool(string(lconst) < string(rconst)), lhs.Len(), bitvec.Zero)
}

func compareLEIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(super.NewBool(lconst <= rconst), lhs.Len(), bitvec.Zero)
}

func compareLEUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(super.NewBool(lconst <= rconst), lhs.Len(), bitvec.Zero)
}

func compareLEFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(super.NewBool(lconst <= rconst), lhs.Len(), bitvec.Zero)
}

func compareLEStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(super.NewBool(lconst <= rconst), lhs.Len(), bitvec.Zero)
}

func compareLEBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) <= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) <= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) <= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(super.NewBool(string(lconst) <= string(rconst)), lhs.Len(), bitvec.Zero)
}

func compareGTIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(super.NewBool(lconst > rconst), lhs.Len(), bitvec.Zero)
}

func compareGTUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(super.NewBool(lconst > rconst), lhs.Len(), bitvec.Zero)
}

func compareGTFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(super.NewBool(lconst > rconst), lhs.Len(), bitvec.Zero)
}

func compareGTStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(super.NewBool(lconst > rconst), lhs.Len(), bitvec.Zero)
}

func compareGTBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) > string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) > string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) > string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(super.NewBool(string(lconst) > string(rconst)), lhs.Len(), bitvec.Zero)
}

func compareGEIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Int)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Int)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(super.NewBool(lconst >= rconst), lhs.Len(), bitvec.Zero)
}

func compareGEUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(super.NewBool(lconst >= rconst), lhs.Len(), bitvec.Zero)
}

func compareGEFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Float)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Float)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(super.NewBool(lconst >= rconst), lhs.Len(), bitvec.Zero)
}

func compareGEStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.String)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.String)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(super.NewBool(lconst >= rconst), lhs.Len(), bitvec.Zero)
}

func compareGEBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) >= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesFlatView(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) >= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesDictView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesViewFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesViewDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesViewView(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesViewConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.View)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) >= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesConstView(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.View)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, bitvec.Zero)
	for k := uint32(0); k < n; k++ {
		if string(lconst) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(super.NewBool(string(lconst) >= string(rconst)), lhs.Len(), bitvec.Zero)
}

var compareFuncs = map[int]func(vector.Any, vector.Any) vector.Any{
	1040: compareEQIntFlatFlat,
	1044: compareEQIntFlatDict,
	1048: compareEQIntFlatView,
	1052: compareEQIntFlatConst,
	1041: compareEQIntDictFlat,
	1045: compareEQIntDictDict,
	1049: compareEQIntDictView,
	1053: compareEQIntDictConst,
	1042: compareEQIntViewFlat,
	1046: compareEQIntViewDict,
	1050: compareEQIntViewView,
	1054: compareEQIntViewConst,
	1043: compareEQIntConstFlat,
	1047: compareEQIntConstDict,
	1051: compareEQIntConstView,
	1055: compareEQIntConstConst,
	1056: compareEQUintFlatFlat,
	1060: compareEQUintFlatDict,
	1064: compareEQUintFlatView,
	1068: compareEQUintFlatConst,
	1057: compareEQUintDictFlat,
	1061: compareEQUintDictDict,
	1065: compareEQUintDictView,
	1069: compareEQUintDictConst,
	1058: compareEQUintViewFlat,
	1062: compareEQUintViewDict,
	1066: compareEQUintViewView,
	1070: compareEQUintViewConst,
	1059: compareEQUintConstFlat,
	1063: compareEQUintConstDict,
	1067: compareEQUintConstView,
	1071: compareEQUintConstConst,
	1072: compareEQFloatFlatFlat,
	1076: compareEQFloatFlatDict,
	1080: compareEQFloatFlatView,
	1084: compareEQFloatFlatConst,
	1073: compareEQFloatDictFlat,
	1077: compareEQFloatDictDict,
	1081: compareEQFloatDictView,
	1085: compareEQFloatDictConst,
	1074: compareEQFloatViewFlat,
	1078: compareEQFloatViewDict,
	1082: compareEQFloatViewView,
	1086: compareEQFloatViewConst,
	1075: compareEQFloatConstFlat,
	1079: compareEQFloatConstDict,
	1083: compareEQFloatConstView,
	1087: compareEQFloatConstConst,
	1088: compareEQStringFlatFlat,
	1092: compareEQStringFlatDict,
	1096: compareEQStringFlatView,
	1100: compareEQStringFlatConst,
	1089: compareEQStringDictFlat,
	1093: compareEQStringDictDict,
	1097: compareEQStringDictView,
	1101: compareEQStringDictConst,
	1090: compareEQStringViewFlat,
	1094: compareEQStringViewDict,
	1098: compareEQStringViewView,
	1102: compareEQStringViewConst,
	1091: compareEQStringConstFlat,
	1095: compareEQStringConstDict,
	1099: compareEQStringConstView,
	1103: compareEQStringConstConst,
	1104: compareEQBytesFlatFlat,
	1108: compareEQBytesFlatDict,
	1112: compareEQBytesFlatView,
	1116: compareEQBytesFlatConst,
	1105: compareEQBytesDictFlat,
	1109: compareEQBytesDictDict,
	1113: compareEQBytesDictView,
	1117: compareEQBytesDictConst,
	1106: compareEQBytesViewFlat,
	1110: compareEQBytesViewDict,
	1114: compareEQBytesViewView,
	1118: compareEQBytesViewConst,
	1107: compareEQBytesConstFlat,
	1111: compareEQBytesConstDict,
	1115: compareEQBytesConstView,
	1119: compareEQBytesConstConst,
	1552: compareNEIntFlatFlat,
	1556: compareNEIntFlatDict,
	1560: compareNEIntFlatView,
	1564: compareNEIntFlatConst,
	1553: compareNEIntDictFlat,
	1557: compareNEIntDictDict,
	1561: compareNEIntDictView,
	1565: compareNEIntDictConst,
	1554: compareNEIntViewFlat,
	1558: compareNEIntViewDict,
	1562: compareNEIntViewView,
	1566: compareNEIntViewConst,
	1555: compareNEIntConstFlat,
	1559: compareNEIntConstDict,
	1563: compareNEIntConstView,
	1567: compareNEIntConstConst,
	1568: compareNEUintFlatFlat,
	1572: compareNEUintFlatDict,
	1576: compareNEUintFlatView,
	1580: compareNEUintFlatConst,
	1569: compareNEUintDictFlat,
	1573: compareNEUintDictDict,
	1577: compareNEUintDictView,
	1581: compareNEUintDictConst,
	1570: compareNEUintViewFlat,
	1574: compareNEUintViewDict,
	1578: compareNEUintViewView,
	1582: compareNEUintViewConst,
	1571: compareNEUintConstFlat,
	1575: compareNEUintConstDict,
	1579: compareNEUintConstView,
	1583: compareNEUintConstConst,
	1584: compareNEFloatFlatFlat,
	1588: compareNEFloatFlatDict,
	1592: compareNEFloatFlatView,
	1596: compareNEFloatFlatConst,
	1585: compareNEFloatDictFlat,
	1589: compareNEFloatDictDict,
	1593: compareNEFloatDictView,
	1597: compareNEFloatDictConst,
	1586: compareNEFloatViewFlat,
	1590: compareNEFloatViewDict,
	1594: compareNEFloatViewView,
	1598: compareNEFloatViewConst,
	1587: compareNEFloatConstFlat,
	1591: compareNEFloatConstDict,
	1595: compareNEFloatConstView,
	1599: compareNEFloatConstConst,
	1600: compareNEStringFlatFlat,
	1604: compareNEStringFlatDict,
	1608: compareNEStringFlatView,
	1612: compareNEStringFlatConst,
	1601: compareNEStringDictFlat,
	1605: compareNEStringDictDict,
	1609: compareNEStringDictView,
	1613: compareNEStringDictConst,
	1602: compareNEStringViewFlat,
	1606: compareNEStringViewDict,
	1610: compareNEStringViewView,
	1614: compareNEStringViewConst,
	1603: compareNEStringConstFlat,
	1607: compareNEStringConstDict,
	1611: compareNEStringConstView,
	1615: compareNEStringConstConst,
	1616: compareNEBytesFlatFlat,
	1620: compareNEBytesFlatDict,
	1624: compareNEBytesFlatView,
	1628: compareNEBytesFlatConst,
	1617: compareNEBytesDictFlat,
	1621: compareNEBytesDictDict,
	1625: compareNEBytesDictView,
	1629: compareNEBytesDictConst,
	1618: compareNEBytesViewFlat,
	1622: compareNEBytesViewDict,
	1626: compareNEBytesViewView,
	1630: compareNEBytesViewConst,
	1619: compareNEBytesConstFlat,
	1623: compareNEBytesConstDict,
	1627: compareNEBytesConstView,
	1631: compareNEBytesConstConst,
	16:   compareLTIntFlatFlat,
	20:   compareLTIntFlatDict,
	24:   compareLTIntFlatView,
	28:   compareLTIntFlatConst,
	17:   compareLTIntDictFlat,
	21:   compareLTIntDictDict,
	25:   compareLTIntDictView,
	29:   compareLTIntDictConst,
	18:   compareLTIntViewFlat,
	22:   compareLTIntViewDict,
	26:   compareLTIntViewView,
	30:   compareLTIntViewConst,
	19:   compareLTIntConstFlat,
	23:   compareLTIntConstDict,
	27:   compareLTIntConstView,
	31:   compareLTIntConstConst,
	32:   compareLTUintFlatFlat,
	36:   compareLTUintFlatDict,
	40:   compareLTUintFlatView,
	44:   compareLTUintFlatConst,
	33:   compareLTUintDictFlat,
	37:   compareLTUintDictDict,
	41:   compareLTUintDictView,
	45:   compareLTUintDictConst,
	34:   compareLTUintViewFlat,
	38:   compareLTUintViewDict,
	42:   compareLTUintViewView,
	46:   compareLTUintViewConst,
	35:   compareLTUintConstFlat,
	39:   compareLTUintConstDict,
	43:   compareLTUintConstView,
	47:   compareLTUintConstConst,
	48:   compareLTFloatFlatFlat,
	52:   compareLTFloatFlatDict,
	56:   compareLTFloatFlatView,
	60:   compareLTFloatFlatConst,
	49:   compareLTFloatDictFlat,
	53:   compareLTFloatDictDict,
	57:   compareLTFloatDictView,
	61:   compareLTFloatDictConst,
	50:   compareLTFloatViewFlat,
	54:   compareLTFloatViewDict,
	58:   compareLTFloatViewView,
	62:   compareLTFloatViewConst,
	51:   compareLTFloatConstFlat,
	55:   compareLTFloatConstDict,
	59:   compareLTFloatConstView,
	63:   compareLTFloatConstConst,
	64:   compareLTStringFlatFlat,
	68:   compareLTStringFlatDict,
	72:   compareLTStringFlatView,
	76:   compareLTStringFlatConst,
	65:   compareLTStringDictFlat,
	69:   compareLTStringDictDict,
	73:   compareLTStringDictView,
	77:   compareLTStringDictConst,
	66:   compareLTStringViewFlat,
	70:   compareLTStringViewDict,
	74:   compareLTStringViewView,
	78:   compareLTStringViewConst,
	67:   compareLTStringConstFlat,
	71:   compareLTStringConstDict,
	75:   compareLTStringConstView,
	79:   compareLTStringConstConst,
	80:   compareLTBytesFlatFlat,
	84:   compareLTBytesFlatDict,
	88:   compareLTBytesFlatView,
	92:   compareLTBytesFlatConst,
	81:   compareLTBytesDictFlat,
	85:   compareLTBytesDictDict,
	89:   compareLTBytesDictView,
	93:   compareLTBytesDictConst,
	82:   compareLTBytesViewFlat,
	86:   compareLTBytesViewDict,
	90:   compareLTBytesViewView,
	94:   compareLTBytesViewConst,
	83:   compareLTBytesConstFlat,
	87:   compareLTBytesConstDict,
	91:   compareLTBytesConstView,
	95:   compareLTBytesConstConst,
	272:  compareLEIntFlatFlat,
	276:  compareLEIntFlatDict,
	280:  compareLEIntFlatView,
	284:  compareLEIntFlatConst,
	273:  compareLEIntDictFlat,
	277:  compareLEIntDictDict,
	281:  compareLEIntDictView,
	285:  compareLEIntDictConst,
	274:  compareLEIntViewFlat,
	278:  compareLEIntViewDict,
	282:  compareLEIntViewView,
	286:  compareLEIntViewConst,
	275:  compareLEIntConstFlat,
	279:  compareLEIntConstDict,
	283:  compareLEIntConstView,
	287:  compareLEIntConstConst,
	288:  compareLEUintFlatFlat,
	292:  compareLEUintFlatDict,
	296:  compareLEUintFlatView,
	300:  compareLEUintFlatConst,
	289:  compareLEUintDictFlat,
	293:  compareLEUintDictDict,
	297:  compareLEUintDictView,
	301:  compareLEUintDictConst,
	290:  compareLEUintViewFlat,
	294:  compareLEUintViewDict,
	298:  compareLEUintViewView,
	302:  compareLEUintViewConst,
	291:  compareLEUintConstFlat,
	295:  compareLEUintConstDict,
	299:  compareLEUintConstView,
	303:  compareLEUintConstConst,
	304:  compareLEFloatFlatFlat,
	308:  compareLEFloatFlatDict,
	312:  compareLEFloatFlatView,
	316:  compareLEFloatFlatConst,
	305:  compareLEFloatDictFlat,
	309:  compareLEFloatDictDict,
	313:  compareLEFloatDictView,
	317:  compareLEFloatDictConst,
	306:  compareLEFloatViewFlat,
	310:  compareLEFloatViewDict,
	314:  compareLEFloatViewView,
	318:  compareLEFloatViewConst,
	307:  compareLEFloatConstFlat,
	311:  compareLEFloatConstDict,
	315:  compareLEFloatConstView,
	319:  compareLEFloatConstConst,
	320:  compareLEStringFlatFlat,
	324:  compareLEStringFlatDict,
	328:  compareLEStringFlatView,
	332:  compareLEStringFlatConst,
	321:  compareLEStringDictFlat,
	325:  compareLEStringDictDict,
	329:  compareLEStringDictView,
	333:  compareLEStringDictConst,
	322:  compareLEStringViewFlat,
	326:  compareLEStringViewDict,
	330:  compareLEStringViewView,
	334:  compareLEStringViewConst,
	323:  compareLEStringConstFlat,
	327:  compareLEStringConstDict,
	331:  compareLEStringConstView,
	335:  compareLEStringConstConst,
	336:  compareLEBytesFlatFlat,
	340:  compareLEBytesFlatDict,
	344:  compareLEBytesFlatView,
	348:  compareLEBytesFlatConst,
	337:  compareLEBytesDictFlat,
	341:  compareLEBytesDictDict,
	345:  compareLEBytesDictView,
	349:  compareLEBytesDictConst,
	338:  compareLEBytesViewFlat,
	342:  compareLEBytesViewDict,
	346:  compareLEBytesViewView,
	350:  compareLEBytesViewConst,
	339:  compareLEBytesConstFlat,
	343:  compareLEBytesConstDict,
	347:  compareLEBytesConstView,
	351:  compareLEBytesConstConst,
	528:  compareGTIntFlatFlat,
	532:  compareGTIntFlatDict,
	536:  compareGTIntFlatView,
	540:  compareGTIntFlatConst,
	529:  compareGTIntDictFlat,
	533:  compareGTIntDictDict,
	537:  compareGTIntDictView,
	541:  compareGTIntDictConst,
	530:  compareGTIntViewFlat,
	534:  compareGTIntViewDict,
	538:  compareGTIntViewView,
	542:  compareGTIntViewConst,
	531:  compareGTIntConstFlat,
	535:  compareGTIntConstDict,
	539:  compareGTIntConstView,
	543:  compareGTIntConstConst,
	544:  compareGTUintFlatFlat,
	548:  compareGTUintFlatDict,
	552:  compareGTUintFlatView,
	556:  compareGTUintFlatConst,
	545:  compareGTUintDictFlat,
	549:  compareGTUintDictDict,
	553:  compareGTUintDictView,
	557:  compareGTUintDictConst,
	546:  compareGTUintViewFlat,
	550:  compareGTUintViewDict,
	554:  compareGTUintViewView,
	558:  compareGTUintViewConst,
	547:  compareGTUintConstFlat,
	551:  compareGTUintConstDict,
	555:  compareGTUintConstView,
	559:  compareGTUintConstConst,
	560:  compareGTFloatFlatFlat,
	564:  compareGTFloatFlatDict,
	568:  compareGTFloatFlatView,
	572:  compareGTFloatFlatConst,
	561:  compareGTFloatDictFlat,
	565:  compareGTFloatDictDict,
	569:  compareGTFloatDictView,
	573:  compareGTFloatDictConst,
	562:  compareGTFloatViewFlat,
	566:  compareGTFloatViewDict,
	570:  compareGTFloatViewView,
	574:  compareGTFloatViewConst,
	563:  compareGTFloatConstFlat,
	567:  compareGTFloatConstDict,
	571:  compareGTFloatConstView,
	575:  compareGTFloatConstConst,
	576:  compareGTStringFlatFlat,
	580:  compareGTStringFlatDict,
	584:  compareGTStringFlatView,
	588:  compareGTStringFlatConst,
	577:  compareGTStringDictFlat,
	581:  compareGTStringDictDict,
	585:  compareGTStringDictView,
	589:  compareGTStringDictConst,
	578:  compareGTStringViewFlat,
	582:  compareGTStringViewDict,
	586:  compareGTStringViewView,
	590:  compareGTStringViewConst,
	579:  compareGTStringConstFlat,
	583:  compareGTStringConstDict,
	587:  compareGTStringConstView,
	591:  compareGTStringConstConst,
	592:  compareGTBytesFlatFlat,
	596:  compareGTBytesFlatDict,
	600:  compareGTBytesFlatView,
	604:  compareGTBytesFlatConst,
	593:  compareGTBytesDictFlat,
	597:  compareGTBytesDictDict,
	601:  compareGTBytesDictView,
	605:  compareGTBytesDictConst,
	594:  compareGTBytesViewFlat,
	598:  compareGTBytesViewDict,
	602:  compareGTBytesViewView,
	606:  compareGTBytesViewConst,
	595:  compareGTBytesConstFlat,
	599:  compareGTBytesConstDict,
	603:  compareGTBytesConstView,
	607:  compareGTBytesConstConst,
	784:  compareGEIntFlatFlat,
	788:  compareGEIntFlatDict,
	792:  compareGEIntFlatView,
	796:  compareGEIntFlatConst,
	785:  compareGEIntDictFlat,
	789:  compareGEIntDictDict,
	793:  compareGEIntDictView,
	797:  compareGEIntDictConst,
	786:  compareGEIntViewFlat,
	790:  compareGEIntViewDict,
	794:  compareGEIntViewView,
	798:  compareGEIntViewConst,
	787:  compareGEIntConstFlat,
	791:  compareGEIntConstDict,
	795:  compareGEIntConstView,
	799:  compareGEIntConstConst,
	800:  compareGEUintFlatFlat,
	804:  compareGEUintFlatDict,
	808:  compareGEUintFlatView,
	812:  compareGEUintFlatConst,
	801:  compareGEUintDictFlat,
	805:  compareGEUintDictDict,
	809:  compareGEUintDictView,
	813:  compareGEUintDictConst,
	802:  compareGEUintViewFlat,
	806:  compareGEUintViewDict,
	810:  compareGEUintViewView,
	814:  compareGEUintViewConst,
	803:  compareGEUintConstFlat,
	807:  compareGEUintConstDict,
	811:  compareGEUintConstView,
	815:  compareGEUintConstConst,
	816:  compareGEFloatFlatFlat,
	820:  compareGEFloatFlatDict,
	824:  compareGEFloatFlatView,
	828:  compareGEFloatFlatConst,
	817:  compareGEFloatDictFlat,
	821:  compareGEFloatDictDict,
	825:  compareGEFloatDictView,
	829:  compareGEFloatDictConst,
	818:  compareGEFloatViewFlat,
	822:  compareGEFloatViewDict,
	826:  compareGEFloatViewView,
	830:  compareGEFloatViewConst,
	819:  compareGEFloatConstFlat,
	823:  compareGEFloatConstDict,
	827:  compareGEFloatConstView,
	831:  compareGEFloatConstConst,
	832:  compareGEStringFlatFlat,
	836:  compareGEStringFlatDict,
	840:  compareGEStringFlatView,
	844:  compareGEStringFlatConst,
	833:  compareGEStringDictFlat,
	837:  compareGEStringDictDict,
	841:  compareGEStringDictView,
	845:  compareGEStringDictConst,
	834:  compareGEStringViewFlat,
	838:  compareGEStringViewDict,
	842:  compareGEStringViewView,
	846:  compareGEStringViewConst,
	835:  compareGEStringConstFlat,
	839:  compareGEStringConstDict,
	843:  compareGEStringConstView,
	847:  compareGEStringConstConst,
	848:  compareGEBytesFlatFlat,
	852:  compareGEBytesFlatDict,
	856:  compareGEBytesFlatView,
	860:  compareGEBytesFlatConst,
	849:  compareGEBytesDictFlat,
	853:  compareGEBytesDictDict,
	857:  compareGEBytesDictView,
	861:  compareGEBytesDictConst,
	850:  compareGEBytesViewFlat,
	854:  compareGEBytesViewDict,
	858:  compareGEBytesViewView,
	862:  compareGEBytesViewConst,
	851:  compareGEBytesConstFlat,
	855:  compareGEBytesConstDict,
	859:  compareGEBytesConstView,
	863:  compareGEBytesConstConst,
}
