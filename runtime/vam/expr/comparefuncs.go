// Code generated by gencomparefuncs.go. DO NOT EDIT.

package expr

import (
	"github.com/brimdata/zed"
	"github.com/brimdata/zed/vector"
)

func compareEQIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(nil, zed.NewBool(lconst == rconst), lhs.Len(), nil)
}

func compareEQUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(nil, zed.NewBool(lconst == rconst), lhs.Len(), nil)
}

func compareEQFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(nil, zed.NewBool(lconst == rconst), lhs.Len(), nil)
}

func compareEQStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) == rconst {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst == r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareEQStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(nil, zed.NewBool(lconst == rconst), lhs.Len(), nil)
}

func compareEQBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) == string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) == string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) == string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) == string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) == string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareEQBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(nil, zed.NewBool(string(lconst) == string(rconst)), lhs.Len(), nil)
}

func compareNEIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(nil, zed.NewBool(lconst != rconst), lhs.Len(), nil)
}

func compareNEUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(nil, zed.NewBool(lconst != rconst), lhs.Len(), nil)
}

func compareNEFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(nil, zed.NewBool(lconst != rconst), lhs.Len(), nil)
}

func compareNEStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) != rconst {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst != r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareNEStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(nil, zed.NewBool(lconst != rconst), lhs.Len(), nil)
}

func compareNEBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) != string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) != string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) != string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) != string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) != string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareNEBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(nil, zed.NewBool(string(lconst) != string(rconst)), lhs.Len(), nil)
}

func compareLTIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(nil, zed.NewBool(lconst < rconst), lhs.Len(), nil)
}

func compareLTUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(nil, zed.NewBool(lconst < rconst), lhs.Len(), nil)
}

func compareLTFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(nil, zed.NewBool(lconst < rconst), lhs.Len(), nil)
}

func compareLTStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) < rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst < r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLTStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(nil, zed.NewBool(lconst < rconst), lhs.Len(), nil)
}

func compareLTBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) < string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) < string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) < string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) < string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) < string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLTBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(nil, zed.NewBool(string(lconst) < string(rconst)), lhs.Len(), nil)
}

func compareLEIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(nil, zed.NewBool(lconst <= rconst), lhs.Len(), nil)
}

func compareLEUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(nil, zed.NewBool(lconst <= rconst), lhs.Len(), nil)
}

func compareLEFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(nil, zed.NewBool(lconst <= rconst), lhs.Len(), nil)
}

func compareLEStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) <= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst <= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareLEStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(nil, zed.NewBool(lconst <= rconst), lhs.Len(), nil)
}

func compareLEBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) <= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) <= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) <= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) <= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) <= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareLEBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(nil, zed.NewBool(string(lconst) <= string(rconst)), lhs.Len(), nil)
}

func compareGTIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(nil, zed.NewBool(lconst > rconst), lhs.Len(), nil)
}

func compareGTUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(nil, zed.NewBool(lconst > rconst), lhs.Len(), nil)
}

func compareGTFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(nil, zed.NewBool(lconst > rconst), lhs.Len(), nil)
}

func compareGTStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) > rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst > r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGTStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(nil, zed.NewBool(lconst > rconst), lhs.Len(), nil)
}

func compareGTBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) > string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) > string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) > string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) > string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) > string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGTBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(nil, zed.NewBool(string(lconst) > string(rconst)), lhs.Len(), nil)
}

func compareGEIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	return vector.NewConst(nil, zed.NewBool(lconst >= rconst), lhs.Len(), nil)
}

func compareGEUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	return vector.NewConst(nil, zed.NewBool(lconst >= rconst), lhs.Len(), nil)
}

func compareGEFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	return vector.NewConst(nil, zed.NewBool(lconst >= rconst), lhs.Len(), nil)
}

func compareGEStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(k) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if l.Value(uint32(lx[k])) >= rconst {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(k) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if lconst >= r.Value(uint32(rx[k])) {
			out.Set(k)
		}
	}
	return out
}

func compareGEStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	return vector.NewConst(nil, zed.NewBool(lconst >= rconst), lhs.Len(), nil)
}

func compareGEBytesFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) >= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Bytes)
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(k)) >= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Bytes)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsBytes()
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(l.Value(uint32(lx[k]))) >= string(rconst) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	r := rhs.(*vector.Bytes)
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) >= string(r.Value(k)) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Bytes)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewBoolEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		if string(lconst) >= string(r.Value(uint32(rx[k]))) {
			out.Set(k)
		}
	}
	return out
}

func compareGEBytesConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsBytes()
	rconst, _ := rhs.(*vector.Const).AsBytes()
	return vector.NewConst(nil, zed.NewBool(string(lconst) >= string(rconst)), lhs.Len(), nil)
}

var compareFuncs = map[int]func(vector.Any, vector.Any) vector.Any{
	528: compareEQIntFlatFlat,
	532: compareEQIntFlatDict,
	536: compareEQIntFlatConst,
	529: compareEQIntDictFlat,
	533: compareEQIntDictDict,
	537: compareEQIntDictConst,
	530: compareEQIntConstFlat,
	534: compareEQIntConstDict,
	538: compareEQIntConstConst,
	544: compareEQUintFlatFlat,
	548: compareEQUintFlatDict,
	552: compareEQUintFlatConst,
	545: compareEQUintDictFlat,
	549: compareEQUintDictDict,
	553: compareEQUintDictConst,
	546: compareEQUintConstFlat,
	550: compareEQUintConstDict,
	554: compareEQUintConstConst,
	560: compareEQFloatFlatFlat,
	564: compareEQFloatFlatDict,
	568: compareEQFloatFlatConst,
	561: compareEQFloatDictFlat,
	565: compareEQFloatDictDict,
	569: compareEQFloatDictConst,
	562: compareEQFloatConstFlat,
	566: compareEQFloatConstDict,
	570: compareEQFloatConstConst,
	576: compareEQStringFlatFlat,
	580: compareEQStringFlatDict,
	584: compareEQStringFlatConst,
	577: compareEQStringDictFlat,
	581: compareEQStringDictDict,
	585: compareEQStringDictConst,
	578: compareEQStringConstFlat,
	582: compareEQStringConstDict,
	586: compareEQStringConstConst,
	592: compareEQBytesFlatFlat,
	596: compareEQBytesFlatDict,
	600: compareEQBytesFlatConst,
	593: compareEQBytesDictFlat,
	597: compareEQBytesDictDict,
	601: compareEQBytesDictConst,
	594: compareEQBytesConstFlat,
	598: compareEQBytesConstDict,
	602: compareEQBytesConstConst,
	784: compareNEIntFlatFlat,
	788: compareNEIntFlatDict,
	792: compareNEIntFlatConst,
	785: compareNEIntDictFlat,
	789: compareNEIntDictDict,
	793: compareNEIntDictConst,
	786: compareNEIntConstFlat,
	790: compareNEIntConstDict,
	794: compareNEIntConstConst,
	800: compareNEUintFlatFlat,
	804: compareNEUintFlatDict,
	808: compareNEUintFlatConst,
	801: compareNEUintDictFlat,
	805: compareNEUintDictDict,
	809: compareNEUintDictConst,
	802: compareNEUintConstFlat,
	806: compareNEUintConstDict,
	810: compareNEUintConstConst,
	816: compareNEFloatFlatFlat,
	820: compareNEFloatFlatDict,
	824: compareNEFloatFlatConst,
	817: compareNEFloatDictFlat,
	821: compareNEFloatDictDict,
	825: compareNEFloatDictConst,
	818: compareNEFloatConstFlat,
	822: compareNEFloatConstDict,
	826: compareNEFloatConstConst,
	832: compareNEStringFlatFlat,
	836: compareNEStringFlatDict,
	840: compareNEStringFlatConst,
	833: compareNEStringDictFlat,
	837: compareNEStringDictDict,
	841: compareNEStringDictConst,
	834: compareNEStringConstFlat,
	838: compareNEStringConstDict,
	842: compareNEStringConstConst,
	848: compareNEBytesFlatFlat,
	852: compareNEBytesFlatDict,
	856: compareNEBytesFlatConst,
	849: compareNEBytesDictFlat,
	853: compareNEBytesDictDict,
	857: compareNEBytesDictConst,
	850: compareNEBytesConstFlat,
	854: compareNEBytesConstDict,
	858: compareNEBytesConstConst,
	16:  compareLTIntFlatFlat,
	20:  compareLTIntFlatDict,
	24:  compareLTIntFlatConst,
	17:  compareLTIntDictFlat,
	21:  compareLTIntDictDict,
	25:  compareLTIntDictConst,
	18:  compareLTIntConstFlat,
	22:  compareLTIntConstDict,
	26:  compareLTIntConstConst,
	32:  compareLTUintFlatFlat,
	36:  compareLTUintFlatDict,
	40:  compareLTUintFlatConst,
	33:  compareLTUintDictFlat,
	37:  compareLTUintDictDict,
	41:  compareLTUintDictConst,
	34:  compareLTUintConstFlat,
	38:  compareLTUintConstDict,
	42:  compareLTUintConstConst,
	48:  compareLTFloatFlatFlat,
	52:  compareLTFloatFlatDict,
	56:  compareLTFloatFlatConst,
	49:  compareLTFloatDictFlat,
	53:  compareLTFloatDictDict,
	57:  compareLTFloatDictConst,
	50:  compareLTFloatConstFlat,
	54:  compareLTFloatConstDict,
	58:  compareLTFloatConstConst,
	64:  compareLTStringFlatFlat,
	68:  compareLTStringFlatDict,
	72:  compareLTStringFlatConst,
	65:  compareLTStringDictFlat,
	69:  compareLTStringDictDict,
	73:  compareLTStringDictConst,
	66:  compareLTStringConstFlat,
	70:  compareLTStringConstDict,
	74:  compareLTStringConstConst,
	80:  compareLTBytesFlatFlat,
	84:  compareLTBytesFlatDict,
	88:  compareLTBytesFlatConst,
	81:  compareLTBytesDictFlat,
	85:  compareLTBytesDictDict,
	89:  compareLTBytesDictConst,
	82:  compareLTBytesConstFlat,
	86:  compareLTBytesConstDict,
	90:  compareLTBytesConstConst,
	144: compareLEIntFlatFlat,
	148: compareLEIntFlatDict,
	152: compareLEIntFlatConst,
	145: compareLEIntDictFlat,
	149: compareLEIntDictDict,
	153: compareLEIntDictConst,
	146: compareLEIntConstFlat,
	150: compareLEIntConstDict,
	154: compareLEIntConstConst,
	160: compareLEUintFlatFlat,
	164: compareLEUintFlatDict,
	168: compareLEUintFlatConst,
	161: compareLEUintDictFlat,
	165: compareLEUintDictDict,
	169: compareLEUintDictConst,
	162: compareLEUintConstFlat,
	166: compareLEUintConstDict,
	170: compareLEUintConstConst,
	176: compareLEFloatFlatFlat,
	180: compareLEFloatFlatDict,
	184: compareLEFloatFlatConst,
	177: compareLEFloatDictFlat,
	181: compareLEFloatDictDict,
	185: compareLEFloatDictConst,
	178: compareLEFloatConstFlat,
	182: compareLEFloatConstDict,
	186: compareLEFloatConstConst,
	192: compareLEStringFlatFlat,
	196: compareLEStringFlatDict,
	200: compareLEStringFlatConst,
	193: compareLEStringDictFlat,
	197: compareLEStringDictDict,
	201: compareLEStringDictConst,
	194: compareLEStringConstFlat,
	198: compareLEStringConstDict,
	202: compareLEStringConstConst,
	208: compareLEBytesFlatFlat,
	212: compareLEBytesFlatDict,
	216: compareLEBytesFlatConst,
	209: compareLEBytesDictFlat,
	213: compareLEBytesDictDict,
	217: compareLEBytesDictConst,
	210: compareLEBytesConstFlat,
	214: compareLEBytesConstDict,
	218: compareLEBytesConstConst,
	272: compareGTIntFlatFlat,
	276: compareGTIntFlatDict,
	280: compareGTIntFlatConst,
	273: compareGTIntDictFlat,
	277: compareGTIntDictDict,
	281: compareGTIntDictConst,
	274: compareGTIntConstFlat,
	278: compareGTIntConstDict,
	282: compareGTIntConstConst,
	288: compareGTUintFlatFlat,
	292: compareGTUintFlatDict,
	296: compareGTUintFlatConst,
	289: compareGTUintDictFlat,
	293: compareGTUintDictDict,
	297: compareGTUintDictConst,
	290: compareGTUintConstFlat,
	294: compareGTUintConstDict,
	298: compareGTUintConstConst,
	304: compareGTFloatFlatFlat,
	308: compareGTFloatFlatDict,
	312: compareGTFloatFlatConst,
	305: compareGTFloatDictFlat,
	309: compareGTFloatDictDict,
	313: compareGTFloatDictConst,
	306: compareGTFloatConstFlat,
	310: compareGTFloatConstDict,
	314: compareGTFloatConstConst,
	320: compareGTStringFlatFlat,
	324: compareGTStringFlatDict,
	328: compareGTStringFlatConst,
	321: compareGTStringDictFlat,
	325: compareGTStringDictDict,
	329: compareGTStringDictConst,
	322: compareGTStringConstFlat,
	326: compareGTStringConstDict,
	330: compareGTStringConstConst,
	336: compareGTBytesFlatFlat,
	340: compareGTBytesFlatDict,
	344: compareGTBytesFlatConst,
	337: compareGTBytesDictFlat,
	341: compareGTBytesDictDict,
	345: compareGTBytesDictConst,
	338: compareGTBytesConstFlat,
	342: compareGTBytesConstDict,
	346: compareGTBytesConstConst,
	400: compareGEIntFlatFlat,
	404: compareGEIntFlatDict,
	408: compareGEIntFlatConst,
	401: compareGEIntDictFlat,
	405: compareGEIntDictDict,
	409: compareGEIntDictConst,
	402: compareGEIntConstFlat,
	406: compareGEIntConstDict,
	410: compareGEIntConstConst,
	416: compareGEUintFlatFlat,
	420: compareGEUintFlatDict,
	424: compareGEUintFlatConst,
	417: compareGEUintDictFlat,
	421: compareGEUintDictDict,
	425: compareGEUintDictConst,
	418: compareGEUintConstFlat,
	422: compareGEUintConstDict,
	426: compareGEUintConstConst,
	432: compareGEFloatFlatFlat,
	436: compareGEFloatFlatDict,
	440: compareGEFloatFlatConst,
	433: compareGEFloatDictFlat,
	437: compareGEFloatDictDict,
	441: compareGEFloatDictConst,
	434: compareGEFloatConstFlat,
	438: compareGEFloatConstDict,
	442: compareGEFloatConstConst,
	448: compareGEStringFlatFlat,
	452: compareGEStringFlatDict,
	456: compareGEStringFlatConst,
	449: compareGEStringDictFlat,
	453: compareGEStringDictDict,
	457: compareGEStringDictConst,
	450: compareGEStringConstFlat,
	454: compareGEStringConstDict,
	458: compareGEStringConstConst,
	464: compareGEBytesFlatFlat,
	468: compareGEBytesFlatDict,
	472: compareGEBytesFlatConst,
	465: compareGEBytesDictFlat,
	469: compareGEBytesDictDict,
	473: compareGEBytesDictConst,
	466: compareGEBytesConstFlat,
	470: compareGEBytesConstDict,
	474: compareGEBytesConstConst,
}
