// Code generated by genarithfuncs.go. DO NOT EDIT.

package expr

import (
	"github.com/brimdata/zed"
	"github.com/brimdata/zed/vector"
)

func arithAddIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(k))
	}
	return out
}

func arithAddIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + rconst)
	}
	return out
}

func arithAddIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(k))
	}
	return out
}

func arithAddIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	var arena *zed.Arena
	val := zed.NewInt64(lconst + rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithAddUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(k))
	}
	return out
}

func arithAddUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + rconst)
	}
	return out
}

func arithAddUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(k))
	}
	return out
}

func arithAddUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	var arena *zed.Arena
	val := zed.NewUint64(lconst + rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithAddFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(k))
	}
	return out
}

func arithAddFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + rconst)
	}
	return out
}

func arithAddFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(k))
	}
	return out
}

func arithAddFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	var arena *zed.Arena
	val := zed.NewFloat64(lconst + rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithAddStringFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewStringEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(k))
	}
	return out
}

func arithAddStringFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewStringEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddStringFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.String)
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewStringEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) + rconst)
	}
	return out
}

func arithAddStringDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewStringEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(k))
	}
	return out
}

func arithAddStringDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewStringEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddStringDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.String)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsString()
	n := lhs.Len()
	out := vector.NewStringEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) + rconst)
	}
	return out
}

func arithAddStringConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	r := rhs.(*vector.String)
	n := lhs.Len()
	out := vector.NewStringEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(k))
	}
	return out
}

func arithAddStringConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.String)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewStringEmpty(n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst + r.Value(uint32(rx[k])))
	}
	return out
}

func arithAddStringConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsString()
	rconst, _ := rhs.(*vector.Const).AsString()
	var arena *zed.Arena
	arena = zed.NewArena()
	val := arena.NewString(lconst + rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithSubIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(k))
	}
	return out
}

func arithSubIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - rconst)
	}
	return out
}

func arithSubIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(k))
	}
	return out
}

func arithSubIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - rconst)
	}
	return out
}

func arithSubIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(k))
	}
	return out
}

func arithSubIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	var arena *zed.Arena
	val := zed.NewInt64(lconst - rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithSubUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(k))
	}
	return out
}

func arithSubUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - rconst)
	}
	return out
}

func arithSubUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(k))
	}
	return out
}

func arithSubUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - rconst)
	}
	return out
}

func arithSubUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(k))
	}
	return out
}

func arithSubUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	var arena *zed.Arena
	val := zed.NewUint64(lconst - rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithSubFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(k))
	}
	return out
}

func arithSubFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) - rconst)
	}
	return out
}

func arithSubFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(k))
	}
	return out
}

func arithSubFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) - rconst)
	}
	return out
}

func arithSubFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(k))
	}
	return out
}

func arithSubFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst - r.Value(uint32(rx[k])))
	}
	return out
}

func arithSubFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	var arena *zed.Arena
	val := zed.NewFloat64(lconst - rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithMulIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(k))
	}
	return out
}

func arithMulIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * rconst)
	}
	return out
}

func arithMulIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(k))
	}
	return out
}

func arithMulIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * rconst)
	}
	return out
}

func arithMulIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(k))
	}
	return out
}

func arithMulIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	var arena *zed.Arena
	val := zed.NewInt64(lconst * rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithMulUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(k))
	}
	return out
}

func arithMulUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * rconst)
	}
	return out
}

func arithMulUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(k))
	}
	return out
}

func arithMulUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * rconst)
	}
	return out
}

func arithMulUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(k))
	}
	return out
}

func arithMulUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	var arena *zed.Arena
	val := zed.NewUint64(lconst * rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithMulFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(k))
	}
	return out
}

func arithMulFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) * rconst)
	}
	return out
}

func arithMulFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(k))
	}
	return out
}

func arithMulFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) * rconst)
	}
	return out
}

func arithMulFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(k))
	}
	return out
}

func arithMulFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst * r.Value(uint32(rx[k])))
	}
	return out
}

func arithMulFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	var arena *zed.Arena
	val := zed.NewFloat64(lconst * rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithDivIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(k))
	}
	return out
}

func arithDivIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / rconst)
	}
	return out
}

func arithDivIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(k))
	}
	return out
}

func arithDivIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / rconst)
	}
	return out
}

func arithDivIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(k))
	}
	return out
}

func arithDivIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	var arena *zed.Arena
	val := zed.NewInt64(lconst / rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithDivUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(k))
	}
	return out
}

func arithDivUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / rconst)
	}
	return out
}

func arithDivUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(k))
	}
	return out
}

func arithDivUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / rconst)
	}
	return out
}

func arithDivUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(k))
	}
	return out
}

func arithDivUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	var arena *zed.Arena
	val := zed.NewUint64(lconst / rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithDivFloatFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(k))
	}
	return out
}

func arithDivFloatFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Float)
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) / rconst)
	}
	return out
}

func arithDivFloatDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(k))
	}
	return out
}

func arithDivFloatDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Float)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsFloat()
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) / rconst)
	}
	return out
}

func arithDivFloatConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	r := rhs.(*vector.Float)
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(k))
	}
	return out
}

func arithDivFloatConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Float)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewFloatEmpty(zed.TypeFloat64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst / r.Value(uint32(rx[k])))
	}
	return out
}

func arithDivFloatConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsFloat()
	rconst, _ := rhs.(*vector.Const).AsFloat()
	var arena *zed.Arena
	val := zed.NewFloat64(lconst / rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithModIntFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(k))
	}
	return out
}

func arithModIntFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Int)
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % rconst)
	}
	return out
}

func arithModIntDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(k))
	}
	return out
}

func arithModIntDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Int)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsInt()
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % rconst)
	}
	return out
}

func arithModIntConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	r := rhs.(*vector.Int)
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(k))
	}
	return out
}

func arithModIntConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Int)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewIntEmpty(zed.TypeInt64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModIntConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsInt()
	rconst, _ := rhs.(*vector.Const).AsInt()
	var arena *zed.Arena
	val := zed.NewInt64(lconst % rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

func arithModUintFlatFlat(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(k))
	}
	return out
}

func arithModUintFlatDict(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintFlatConst(lhs, rhs vector.Any) vector.Any {
	l := lhs.(*vector.Uint)
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(k) % rconst)
	}
	return out
}

func arithModUintDictFlat(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(k))
	}
	return out
}

func arithModUintDictDict(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintDictConst(lhs, rhs vector.Any) vector.Any {
	ld := lhs.(*vector.Dict)
	l := ld.Any.(*vector.Uint)
	lx := ld.Index
	rconst, _ := rhs.(*vector.Const).AsUint()
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(l.Value(uint32(lx[k])) % rconst)
	}
	return out
}

func arithModUintConstFlat(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	r := rhs.(*vector.Uint)
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(k))
	}
	return out
}

func arithModUintConstDict(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rd := rhs.(*vector.Dict)
	r := rd.Any.(*vector.Uint)
	rx := rd.Index
	n := lhs.Len()
	out := vector.NewUintEmpty(zed.TypeUint64, n, nil)
	for k := uint32(0); k < n; k++ {
		out.Append(lconst % r.Value(uint32(rx[k])))
	}
	return out
}

func arithModUintConstConst(lhs, rhs vector.Any) vector.Any {
	lconst, _ := lhs.(*vector.Const).AsUint()
	rconst, _ := rhs.(*vector.Const).AsUint()
	var arena *zed.Arena
	val := zed.NewUint64(lconst % rconst)
	return vector.NewConst(arena, val, lhs.Len(), nil)
}

var arithFuncs = map[int]func(vector.Any, vector.Any) vector.Any{
	16:  arithAddIntFlatFlat,
	20:  arithAddIntFlatDict,
	24:  arithAddIntFlatConst,
	17:  arithAddIntDictFlat,
	21:  arithAddIntDictDict,
	25:  arithAddIntDictConst,
	18:  arithAddIntConstFlat,
	22:  arithAddIntConstDict,
	26:  arithAddIntConstConst,
	32:  arithAddUintFlatFlat,
	36:  arithAddUintFlatDict,
	40:  arithAddUintFlatConst,
	33:  arithAddUintDictFlat,
	37:  arithAddUintDictDict,
	41:  arithAddUintDictConst,
	34:  arithAddUintConstFlat,
	38:  arithAddUintConstDict,
	42:  arithAddUintConstConst,
	48:  arithAddFloatFlatFlat,
	52:  arithAddFloatFlatDict,
	56:  arithAddFloatFlatConst,
	49:  arithAddFloatDictFlat,
	53:  arithAddFloatDictDict,
	57:  arithAddFloatDictConst,
	50:  arithAddFloatConstFlat,
	54:  arithAddFloatConstDict,
	58:  arithAddFloatConstConst,
	64:  arithAddStringFlatFlat,
	68:  arithAddStringFlatDict,
	72:  arithAddStringFlatConst,
	65:  arithAddStringDictFlat,
	69:  arithAddStringDictDict,
	73:  arithAddStringDictConst,
	66:  arithAddStringConstFlat,
	70:  arithAddStringConstDict,
	74:  arithAddStringConstConst,
	144: arithSubIntFlatFlat,
	148: arithSubIntFlatDict,
	152: arithSubIntFlatConst,
	145: arithSubIntDictFlat,
	149: arithSubIntDictDict,
	153: arithSubIntDictConst,
	146: arithSubIntConstFlat,
	150: arithSubIntConstDict,
	154: arithSubIntConstConst,
	160: arithSubUintFlatFlat,
	164: arithSubUintFlatDict,
	168: arithSubUintFlatConst,
	161: arithSubUintDictFlat,
	165: arithSubUintDictDict,
	169: arithSubUintDictConst,
	162: arithSubUintConstFlat,
	166: arithSubUintConstDict,
	170: arithSubUintConstConst,
	176: arithSubFloatFlatFlat,
	180: arithSubFloatFlatDict,
	184: arithSubFloatFlatConst,
	177: arithSubFloatDictFlat,
	181: arithSubFloatDictDict,
	185: arithSubFloatDictConst,
	178: arithSubFloatConstFlat,
	182: arithSubFloatConstDict,
	186: arithSubFloatConstConst,
	272: arithMulIntFlatFlat,
	276: arithMulIntFlatDict,
	280: arithMulIntFlatConst,
	273: arithMulIntDictFlat,
	277: arithMulIntDictDict,
	281: arithMulIntDictConst,
	274: arithMulIntConstFlat,
	278: arithMulIntConstDict,
	282: arithMulIntConstConst,
	288: arithMulUintFlatFlat,
	292: arithMulUintFlatDict,
	296: arithMulUintFlatConst,
	289: arithMulUintDictFlat,
	293: arithMulUintDictDict,
	297: arithMulUintDictConst,
	290: arithMulUintConstFlat,
	294: arithMulUintConstDict,
	298: arithMulUintConstConst,
	304: arithMulFloatFlatFlat,
	308: arithMulFloatFlatDict,
	312: arithMulFloatFlatConst,
	305: arithMulFloatDictFlat,
	309: arithMulFloatDictDict,
	313: arithMulFloatDictConst,
	306: arithMulFloatConstFlat,
	310: arithMulFloatConstDict,
	314: arithMulFloatConstConst,
	400: arithDivIntFlatFlat,
	404: arithDivIntFlatDict,
	408: arithDivIntFlatConst,
	401: arithDivIntDictFlat,
	405: arithDivIntDictDict,
	409: arithDivIntDictConst,
	402: arithDivIntConstFlat,
	406: arithDivIntConstDict,
	410: arithDivIntConstConst,
	416: arithDivUintFlatFlat,
	420: arithDivUintFlatDict,
	424: arithDivUintFlatConst,
	417: arithDivUintDictFlat,
	421: arithDivUintDictDict,
	425: arithDivUintDictConst,
	418: arithDivUintConstFlat,
	422: arithDivUintConstDict,
	426: arithDivUintConstConst,
	432: arithDivFloatFlatFlat,
	436: arithDivFloatFlatDict,
	440: arithDivFloatFlatConst,
	433: arithDivFloatDictFlat,
	437: arithDivFloatDictDict,
	441: arithDivFloatDictConst,
	434: arithDivFloatConstFlat,
	438: arithDivFloatConstDict,
	442: arithDivFloatConstConst,
	528: arithModIntFlatFlat,
	532: arithModIntFlatDict,
	536: arithModIntFlatConst,
	529: arithModIntDictFlat,
	533: arithModIntDictDict,
	537: arithModIntDictConst,
	530: arithModIntConstFlat,
	534: arithModIntConstDict,
	538: arithModIntConstConst,
	544: arithModUintFlatFlat,
	548: arithModUintFlatDict,
	552: arithModUintFlatConst,
	545: arithModUintDictFlat,
	549: arithModUintDictDict,
	553: arithModUintDictConst,
	546: arithModUintConstFlat,
	550: arithModUintConstDict,
	554: arithModUintConstConst,
}
