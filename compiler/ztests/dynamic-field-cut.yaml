script: |
  echo '{a:"hi",b:"hello"}' | zq -z 'cut this[a][b] := "world"' -
  echo "// ==="
  echo '{a:{b:"hello"}}' | zq -z 'cut this[a.b]:="world"' -
  echo "// ==="
  echo '{a:"hello"}' | zq -z 'cut this[this["a"]] := "world"' -
  echo "// ==="
  echo '{a:{},b:"hello"}' | zq -z 'cut a[b] := "world"' -
  echo "// ==="
  echo '{a:"foo"}' | zq -z 'cut this[a]["bar"] := "baz"' -
  echo "// ==="
  # runtime error cases
  echo '{a:"hello",b:"hello"}' | zq -z 'cut this[a] := "world1", this[b] := "world2"' -
  echo "// ==="
  echo '{a:"foo",b:"bar"}' | zq -z 'cut this[a][b] := "world", this[a] := "world"' -
  echo "// ==="
  # will display nothing because put ignores missing error type
  echo {} | zq -z 'cut this[doesnotexist] := "world"' - 
  # semantic error cases
  ! echo {} | zq -z 'op foo(): ( yield "error" ) cut this[foo] := "hello world"' -

outputs:
  - name: stdout
    data: |
      {hi:{hello:"world"}}
      // ===
      {hello:"world"}
      // ===
      {hello:"world"}
      // ===
      {a:{hello:"world"}}
      // ===
      {foo:{bar:"baz"}}
      // ===
      error("cut: duplicate field: \"hello\"")
      // ===
      error("cut: duplicate field: \"foo\"")
      // ===
  - name: stderr
    data: |
      symbol "foo" is not bound to an expression
